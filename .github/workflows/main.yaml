name: Deploy

on:
  push:
    branches:
      - main

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.AWS_ECR_REPO }}
  BACKEND_CONTAINER_NAME: backend-container
  FRONTEND_CONTAINER_NAME: frontend-container

jobs:
  build-and-deploy:
    name: Build and Deploy Docker Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up environment variables
        run: |
          echo "ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_ENV
          echo "TIMESTAMP=$(date +%s)" >> $GITHUB_ENV
          echo "DATE_TAG=$(date +%Y%m%d)" >> $GITHUB_ENV
          echo "BACKEND_IMAGE_TAG=backend-${{ github.sha }}-${{ github.run_number }}-${{ env.TIMESTAMP }}" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE_TAG=frontend-${{ github.sha }}-${{ github.run_number }}-${{ env.TIMESTAMP }}" >> $GITHUB_ENV

      - name: Check for existing images and pull if available
        run: |
          if docker pull $ECR_REGISTRY/$ECR_REPOSITORY:backend-$DATE_TAG || \
             docker pull $ECR_REGISTRY/$ECR_REPOSITORY:backend-$(date -d "yesterday" +%Y%m%d); then
            echo "BACKEND_CACHE_EXISTS=true" >> $GITHUB_ENV
          else
            echo "BACKEND_CACHE_EXISTS=false" >> $GITHUB_ENV
          fi
          if docker pull $ECR_REGISTRY/$ECR_REPOSITORY:frontend-$DATE_TAG || \
             docker pull $ECR_REGISTRY/$ECR_REPOSITORY:frontend-$(date -d "yesterday" +%Y%m%d); then
            echo "FRONTEND_CACHE_EXISTS=true" >> $GITHUB_ENV
          else
            echo "FRONTEND_CACHE_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: Build and measure time (with cache if available)
        run: |
          build_and_measure() {
            local image_name=$1
            local cache_exists=$2
            local cache_from=$3
            local image_tag=$4
            local date_tag=$5
            local context_path=
            echo "Building $image_name (Cache: $cache_exists)"
            start_time=$(date +%s)
            if [ "$cache_exists" = "true" ]; then
              docker build \
                --cache-from $cache_from \
                -t $ECR_REGISTRY/$ECR_REPOSITORY:$image_tag \
                -t $ECR_REGISTRY/$ECR_REPOSITORY:$date_tag \
                $context_path
            else
              docker build \
                -t $ECR_REGISTRY/$ECR_REPOSITORY:$image_tag \
                -t $ECR_REGISTRY/$ECR_REPOSITORY:$date_tag \
                $context_path
            fi
            end_time=$(date +%s)
            build_time=$((end_time - start_time))
            echo "BUILD_TIME_${image_name^^}=$build_time" >> $GITHUB_ENV
            echo "$image_name build time: $build_time seconds"

          build_and_measure "backend" "$BACKEND_CACHE_EXISTS" "$ECR_REGISTRY/$ECR_REPOSITORY:backend-$DATE_TAG" "$BACKEND_IMAGE_TAG" "backend-$DATE_TAG" "./api"
          build_and_measure "frontend" "$FRONTEND_CACHE_EXISTS" "$ECR_REGISTRY/$ECR_REPOSITORY:frontend-$DATE_TAG" "$FRONTEND_IMAGE_TAG" "frontend-$DATE_TAG" "./fronten
          echo "===== Build Time Summary ====="
          echo "Backend build time: $BUILD_TIME_BACKEND seconds (Cache: $BACKEND_CACHE_EXISTS)"
          echo "Frontend build time: $BUILD_TIME_FRONTEND seconds (Cache: $FRONTEND_CACHE_EXISTS)"
          echo "==============================="

      - name: Save build times to file
        run: |
          echo "Build Date: $(date)" >> build_times.txt
          echo "Backend build time: $BUILD_TIME_BACKEND seconds (Cache: $BACKEND_CACHE_EXISTS)" >> build_times.txt
          echo "Frontend build time: $BUILD_TIME_FRONTEND seconds (Cache: $FRONTEND_CACHE_EXISTS)" >> build_times.txt
          echo "---" >> build_times.t
      - name: Upload build times
        uses: actions/upload-artifact@v2
        with:
          name: build-times
          path: build_times.txt

      - name: Push Docker images
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$BACKEND_IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:backend-$DATE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$FRONTEND_IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:frontend-$DATE_TAG

      - name: Fetch EC2 Instance IDs
        run: |
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=cwc-private-ec2-1,cwc-private-ec2-2" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[?State.Name=='running'].[InstanceId]" \
            --output text | tr '\n' ' ')
          echo "INSTANCE_IDS=$INSTANCE_IDS" >> $GITHUB_ENV

      - name: Fetch RDS Endpoint
        run: |
          RDS_ENDPOINT=$(aws ssm get-parameter --name "/cwc/rds/endpoint" --with-decryption --query "Parameter.Value" --output text)
          echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
          echo "RDS_HOST=$(echo $RDS_ENDPOINT | cut -d':' -f1)" >> $GITHUB_ENV
          echo "RDS_PORT=$(echo $RDS_ENDPOINT | cut -d':' -f2)" >> $GITHUB_ENV

      - name: Deploy to EC2 Instances
        env:
          BACKEND_ENV: >-
            NODE_ENV=production
            DB_HOST=${{ env.RDS_HOST }}
            DB_PORT=${{ secrets.DB_PORT }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_NAME=${{ secrets.DB_NAME }}
            DISABLE_DB=false
            DB_SSL=true
        run: |
          deploy_container() {
            local instance_id=$1
            local container_name=$2
            local image_tag=$3
            local port_mapping=$4
            local env_vars=$5

            # Properly format env vars for docker run command
            local formatted_env_vars=""
            if [ -n "$env_vars" ]; then
              formatted_env_vars=$(echo "$env_vars" | sed 's/^/-e /' | sed 's/ / -e /g')
            fi

            aws ssm send-command \
              --instance-ids "$instance_id" \
              --document-name "AWS-RunShellScript" \
              --comment "Deploy $container_name" \
              --parameters '{
                "commands": [
                  "aws ecr get-login-password --region '"$AWS_REGION"' | docker login --username AWS --password-stdin '"$ECR_REGISTRY"'",
                  "docker pull '"$ECR_REGISTRY/$ECR_REPOSITORY:$image_tag"'",
                  "docker stop '"$container_name"' || true",
                  "docker rm '"$container_name"' || true",
                  "docker run -d --name '"$container_name"' '"$port_mapping"' '"$formatted_env_vars"' '"$ECR_REGISTRY/$ECR_REPOSITORY:$image_tag"'",
                  "docker logs '"$container_name"'"
                ]
              }' \
              --output text
          }

          for instance_id in $INSTANCE_IDS; do
            deploy_container "$instance_id" "$BACKEND_CONTAINER_NAME" "$BACKEND_IMAGE_TAG" "-p 3001:3005" "$BACKEND_ENV"
            deploy_container "$instance_id" "$FRONTEND_CONTAINER_NAME" "$FRONTEND_IMAGE_TAG" "-p 80:3000" ""
          done
